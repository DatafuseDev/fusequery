statement ok
create or replace database test_auto_rebuild_missing

statement ok
use test_auto_rebuild_missing;


statement ok
create or replace table t(c int) 'fs:///tmp/test_auto_rebuild_missing/';

statement ok
create or replace stage rebuild_missing_bloom_index_stage 'fs:///tmp/test_auto_rebuild_missing/';

# check table meta cache is disabled
query TT
select name, value from system.configs where  name = 'enable_table_meta_cache';
----
enable_table_meta_cache false

statement ok
insert into t values(1), (3), (5), (7), (9);


query T
explain select * from t where c > 0
----
Filter
├── output columns: [t.c (#0)]
├── filters: [is_true(t.c (#0) > 0)]
├── estimated rows: 5.00
└── TableScan
    ├── table: default.test_auto_rebuild_missing.t
    ├── output columns: [c (#0)]
    ├── read rows: 5
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [is_true(t.c (#0) > 0)], limit: NONE]
    └── estimated rows: 5.00


# bloom index exists, expect one block pruned by bloom filter
query T
explain select * from t where c = 6;
----
Filter
├── output columns: [t.c (#0)]
├── filters: [is_true(t.c (#0) = 6)]
├── estimated rows: 1.00
└── TableScan
    ├── table: default.test_auto_rebuild_missing.t
    ├── output columns: [c (#0)]
    ├── read rows: 0
    ├── read size: 0
    ├── partitions total: 1
    ├── partitions scanned: 0
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 0>]
    ├── push downs: [filters: [is_true(t.c (#0) = 6)], limit: NONE]
    └── estimated rows: 5.00

# disable auto fix missing bloom index
statement ok
set enable_auto_fix_missing_bloom_index = 0;

# remove bloom index files
statement ok
remove @rebuild_missing_bloom_index_stage pattern = '.*/_i_b_v2/.*.parquet';

# bloom index does not exist, expect no block pruned by bloom filter
query T
explain select * from t where c = 6;
----
Filter
├── output columns: [t.c (#0)]
├── filters: [is_true(t.c (#0) = 6)]
├── estimated rows: 1.00
└── TableScan
    ├── table: default.test_auto_rebuild_missing.t
    ├── output columns: [c (#0)]
    ├── read rows: 5
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
    ├── push downs: [filters: [is_true(t.c (#0) = 6)], limit: NONE]
    └── estimated rows: 5.00

# expects empty result set
query I
select * from t where c = 6;
----

# enable auto fix missing bloom index
statement ok
set enable_auto_fix_missing_bloom_index = 1;

# bloom index should be re-built during pruning, expect 1 block pruned by bloom filter
query T
explain select * from t where c = 6;
----
Filter
├── output columns: [t.c (#0)]
├── filters: [is_true(t.c (#0) = 6)]
├── estimated rows: 1.00
└── TableScan
    ├── table: default.test_auto_rebuild_missing.t
    ├── output columns: [c (#0)]
    ├── read rows: 0
    ├── read size: 0
    ├── partitions total: 1
    ├── partitions scanned: 0
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 0>]
    ├── push downs: [filters: [is_true(t.c (#0) = 6)], limit: NONE]
    └── estimated rows: 5.00

# expects empty result set
query I
select * from t where c = 6;
----
