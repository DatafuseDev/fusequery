// Copyright 2021 Datafuse Labs.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::fs::File;
use std::io::Write;
use std::path::Path;

use common_datavalues::prelude::*;

pub fn codegen_arithmetic_type() {
    use DataType::*;
    use DataValueBinaryOperator::*;
    use DataValueUnaryOperator::*;

    let dest = Path::new("common/datavalues/src/types");
    let path = dest.join("arithmetics_type.rs");

    let mut file = File::create(&path).expect("open");
    // Write the head.
    writeln!(
        file,
        "// Copyright 2021 Datafuse Labs.
//
// Licensed under the Apache License, Version 2.0 (the \"License\");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an \"AS IS\" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This code is generated by common/codegen. DO NOT EDIT.
use crate::DFPrimitiveType;

pub trait ResultTypeOfBinary {{
    type AddMul: DFPrimitiveType;
    type Minus: DFPrimitiveType;
    type IntDiv: DFPrimitiveType;
    type Modulo: DFPrimitiveType;
    type LeastSuper: DFPrimitiveType;
}}

pub trait ResultTypeOfUnary {{
    type Negate: DFPrimitiveType;
}}"
    )
    .unwrap();

    let lhs = vec![
        UInt8(true),
        UInt16(true),
        UInt32(true),
        UInt64(true),
        Int8(true),
        Int16(true),
        Int32(true),
        Int64(true),
        Float32(true),
        Float64(true),
        UInt8(false),
        UInt16(false),
        UInt32(false),
        UInt64(false),
        Int8(false),
        Int16(false),
        Int32(false),
        Int64(false),
        Float32(false),
        Float64(false),
    ];
    let rhs = lhs.clone();
    for left in &lhs {
        for right in &rhs {
            let add_mul = numerical_arithmetic_coercion(&Plus, left, right).unwrap();
            let minus = numerical_arithmetic_coercion(&Minus, left, right).unwrap();
            let int_div = numerical_arithmetic_coercion(&IntDiv, left, right).unwrap();
            let modulo = numerical_arithmetic_coercion(&Modulo, left, right).unwrap();
            let least_super = numerical_coercion(left, right, true).unwrap();
            writeln!(
                file,
                "
impl ResultTypeOfBinary for ({}, {}) {{
    type AddMul = {};
    type Minus = {};
    type IntDiv = {};
    type Modulo = {};
    type LeastSuper = {};
}}",
                to_primitive_str(left),
                to_primitive_str(right),
                to_primitive_str(&add_mul),
                to_primitive_str(&minus),
                to_primitive_str(&int_div),
                to_primitive_str(&modulo),
                to_primitive_str(&least_super),
            )
            .unwrap();
        }
    }

    for arg in &lhs {
        let negate = numerical_unary_arithmetic_coercion(&Negate, arg).unwrap();
        writeln!(
            file,
            "
impl ResultTypeOfUnary for {} {{
    type Negate = {};
}}",
            to_primitive_str(arg),
            to_primitive_str(&negate),
        )
        .unwrap();
    }
    file.flush().unwrap();
}

fn to_primitive_str(dt: &DataType) -> &str {
    use DataType::*;
    match dt {
        UInt8(_) => "u8",
        UInt16(_) => "u16",
        UInt32(_) => "u32",
        UInt64(_) => "u64",
        Int8(_) => "i8",
        Int16(_) => "i16",
        Int32(_) => "i32",
        Int64(_) => "i64",
        Float32(_) => "f32",
        Float64(_) => "f64",
        _ => panic!("unsupported data type"),
    }
}
