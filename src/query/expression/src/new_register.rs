// Copyright 2021 Datafuse Labs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This code is generated by src/query/codegen/src/writes/register.rs. DO NOT EDIT.

use crate::types::nullable::NullableColumn;
use crate::types::*;
use crate::values::Value;
use crate::EvalContext;

pub fn vectorize_1_arg<I1: ArgType, O: ArgType>(
    func: impl Fn(I1::ScalarRef<'_>, &mut EvalContext) -> O::Scalar + Copy + Send + Sync,
) -> impl Fn(Value<I1>, &mut EvalContext) -> Value<O> + Copy + Send + Sync {
    move |arg1, ctx| match arg1 {
        Value::Scalar(arg1) => {
            let result = func(I1::to_scalar_ref(&arg1), ctx);
            Value::Scalar(result)
        }
        Value::Column(arg1) => {
            let generics = ctx.generics.to_vec();
            let iter = I1::iter_column(&arg1).map(|arg1| func(arg1, ctx));
            let col = O::column_from_iter(iter, &generics);
            Value::Column(col)
        }
    }
}

pub fn vectorize_2_arg<I1: ArgType, I2: ArgType, O: ArgType>(
    func: impl Fn(I1::ScalarRef<'_>, I2::ScalarRef<'_>, &mut EvalContext) -> O::Scalar
    + Copy
    + Send
    + Sync,
) -> impl Fn(Value<I1>, Value<I2>, &mut EvalContext) -> Value<O> + Copy + Send + Sync {
    move |arg1, arg2, ctx| match (arg1, arg2) {
        (Value::Scalar(arg1), Value::Scalar(arg2)) => {
            let result = func(I1::to_scalar_ref(&arg1), I2::to_scalar_ref(&arg2), ctx);
            Value::Scalar(result)
        }
        (Value::Scalar(arg1), Value::Column(arg2)) => {
            let generics = ctx.generics.to_vec();
            let iter = I2::iter_column(&arg2).map(|arg2| {
                let arg1 = I1::to_scalar_ref(&arg1);
                func(arg1, arg2, ctx)
            });
            let col = O::column_from_iter(iter, &generics);
            Value::Column(col)
        }
        (Value::Column(arg1), Value::Scalar(arg2)) => {
            let generics = ctx.generics.to_vec();
            let iter = I1::iter_column(&arg1).map(|arg1| {
                let arg2 = I2::to_scalar_ref(&arg2);
                func(arg1, arg2, ctx)
            });
            let col = O::column_from_iter(iter, &generics);
            Value::Column(col)
        }
        (Value::Column(arg1), Value::Column(arg2)) => {
            let generics = ctx.generics.to_vec();
            let iter = I1::iter_column(&arg1)
                .zip(I2::iter_column(&arg2))
                .map(|(arg1, arg2)| func(arg1, arg2, ctx));
            let col = O::column_from_iter(iter, &generics);
            Value::Column(col)
        }
    }
}

pub fn vectorize_3_arg<I1: ArgType, I2: ArgType, I3: ArgType, O: ArgType>(
    func: impl Fn(
        I1::ScalarRef<'_>,
        I2::ScalarRef<'_>,
        I3::ScalarRef<'_>,
        &mut EvalContext,
    ) -> O::Scalar
    + Copy
    + Send
    + Sync,
) -> impl Fn(Value<I1>, Value<I2>, Value<I3>, &mut EvalContext) -> Value<O> + Copy + Send + Sync {
    move |arg1, arg2, arg3, ctx| {
        let generics = ctx.generics.to_vec();
        let iter = (0..ctx.num_rows).map(|index| {
            let arg1 = unsafe { arg1.index_unchecked(index) };
            let arg2 = unsafe { arg2.index_unchecked(index) };
            let arg3 = unsafe { arg3.index_unchecked(index) };
            func(arg1, arg2, arg3, ctx)
        });
        let col = O::column_from_iter(iter, &generics);
        Value::Column(col)
    }
}

pub fn vectorize_4_arg<I1: ArgType, I2: ArgType, I3: ArgType, I4: ArgType, O: ArgType>(
    func: impl Fn(
        I1::ScalarRef<'_>,
        I2::ScalarRef<'_>,
        I3::ScalarRef<'_>,
        I4::ScalarRef<'_>,
        &mut EvalContext,
    ) -> O::Scalar
    + Copy
    + Send
    + Sync,
) -> impl Fn(Value<I1>, Value<I2>, Value<I3>, Value<I4>, &mut EvalContext) -> Value<O> + Copy + Send + Sync
{
    move |arg1, arg2, arg3, arg4, ctx| {
        let generics = ctx.generics.to_vec();
        let iter = (0..ctx.num_rows).map(|index| {
            let arg1 = unsafe { arg1.index_unchecked(index) };
            let arg2 = unsafe { arg2.index_unchecked(index) };
            let arg3 = unsafe { arg3.index_unchecked(index) };
            let arg4 = unsafe { arg4.index_unchecked(index) };
            func(arg1, arg2, arg3, arg4, ctx)
        });
        let col = O::column_from_iter(iter, &generics);
        Value::Column(col)
    }
}

pub fn vectorize_5_arg<
    I1: ArgType,
    I2: ArgType,
    I3: ArgType,
    I4: ArgType,
    I5: ArgType,
    O: ArgType,
>(
    func: impl Fn(
        I1::ScalarRef<'_>,
        I2::ScalarRef<'_>,
        I3::ScalarRef<'_>,
        I4::ScalarRef<'_>,
        I5::ScalarRef<'_>,
        &mut EvalContext,
    ) -> O::Scalar
    + Copy
    + Send
    + Sync,
) -> impl Fn(Value<I1>, Value<I2>, Value<I3>, Value<I4>, Value<I5>, &mut EvalContext) -> Value<O>
+ Copy
+ Send
+ Sync {
    move |arg1, arg2, arg3, arg4, arg5, ctx| {
        let generics = ctx.generics.to_vec();
        let iter = (0..ctx.num_rows).map(|index| {
            let arg1 = unsafe { arg1.index_unchecked(index) };
            let arg2 = unsafe { arg2.index_unchecked(index) };
            let arg3 = unsafe { arg3.index_unchecked(index) };
            let arg4 = unsafe { arg4.index_unchecked(index) };
            let arg5 = unsafe { arg5.index_unchecked(index) };
            func(arg1, arg2, arg3, arg4, arg5, ctx)
        });
        let col = O::column_from_iter(iter, &generics);
        Value::Column(col)
    }
}

pub fn vectorize_with_builder_1_arg<I1: ArgType, O: ArgType>(
    func: impl Fn(I1::ScalarRef<'_>, &mut O::ColumnBuilder, &mut EvalContext) + Copy + Send + Sync,
) -> impl Fn(Value<I1>, &mut EvalContext) -> Value<O> + Copy + Send + Sync {
    move |arg1, ctx| {
        let generics = ctx.generics.to_vec();
        let mut builder = O::create_builder(ctx.num_rows, &generics);
        for index in 0..ctx.num_rows {
            let arg1 = unsafe { arg1.index_unchecked(index) };
            func(arg1, &mut builder, ctx);
        }
        Value::Column(O::build_column(builder))
    }
}

pub fn vectorize_with_builder_2_arg<I1: ArgType, I2: ArgType, O: ArgType>(
    func: impl Fn(I1::ScalarRef<'_>, I2::ScalarRef<'_>, &mut O::ColumnBuilder, &mut EvalContext)
    + Copy
    + Send
    + Sync,
) -> impl Fn(Value<I1>, Value<I2>, &mut EvalContext) -> Value<O> + Copy + Send + Sync {
    move |arg1, arg2, ctx| {
        let generics = ctx.generics.to_vec();
        let mut builder = O::create_builder(ctx.num_rows, &generics);
        for index in 0..ctx.num_rows {
            let arg1 = unsafe { arg1.index_unchecked(index) };
            let arg2 = unsafe { arg2.index_unchecked(index) };
            func(arg1, arg2, &mut builder, ctx);
        }
        Value::Column(O::build_column(builder))
    }
}

pub fn vectorize_with_builder_3_arg<I1: ArgType, I2: ArgType, I3: ArgType, O: ArgType>(
    func: impl Fn(
        I1::ScalarRef<'_>,
        I2::ScalarRef<'_>,
        I3::ScalarRef<'_>,
        &mut O::ColumnBuilder,
        &mut EvalContext,
    ) + Copy
    + Send
    + Sync,
) -> impl Fn(Value<I1>, Value<I2>, Value<I3>, &mut EvalContext) -> Value<O> + Copy + Send + Sync {
    move |arg1, arg2, arg3, ctx| {
        let generics = ctx.generics.to_vec();
        let mut builder = O::create_builder(ctx.num_rows, &generics);
        for index in 0..ctx.num_rows {
            let arg1 = unsafe { arg1.index_unchecked(index) };
            let arg2 = unsafe { arg2.index_unchecked(index) };
            let arg3 = unsafe { arg3.index_unchecked(index) };
            func(arg1, arg2, arg3, &mut builder, ctx);
        }
        Value::Column(O::build_column(builder))
    }
}

pub fn vectorize_with_builder_4_arg<
    I1: ArgType,
    I2: ArgType,
    I3: ArgType,
    I4: ArgType,
    O: ArgType,
>(
    func: impl Fn(
        I1::ScalarRef<'_>,
        I2::ScalarRef<'_>,
        I3::ScalarRef<'_>,
        I4::ScalarRef<'_>,
        &mut O::ColumnBuilder,
        &mut EvalContext,
    ) + Copy
    + Send
    + Sync,
) -> impl Fn(Value<I1>, Value<I2>, Value<I3>, Value<I4>, &mut EvalContext) -> Value<O> + Copy + Send + Sync
{
    move |arg1, arg2, arg3, arg4, ctx| {
        let generics = ctx.generics.to_vec();
        let mut builder = O::create_builder(ctx.num_rows, &generics);
        for index in 0..ctx.num_rows {
            let arg1 = unsafe { arg1.index_unchecked(index) };
            let arg2 = unsafe { arg2.index_unchecked(index) };
            let arg3 = unsafe { arg3.index_unchecked(index) };
            let arg4 = unsafe { arg4.index_unchecked(index) };
            func(arg1, arg2, arg3, arg4, &mut builder, ctx);
        }
        Value::Column(O::build_column(builder))
    }
}

pub fn vectorize_with_builder_5_arg<
    I1: ArgType,
    I2: ArgType,
    I3: ArgType,
    I4: ArgType,
    I5: ArgType,
    O: ArgType,
>(
    func: impl Fn(
        I1::ScalarRef<'_>,
        I2::ScalarRef<'_>,
        I3::ScalarRef<'_>,
        I4::ScalarRef<'_>,
        I5::ScalarRef<'_>,
        &mut O::ColumnBuilder,
        &mut EvalContext,
    ) + Copy
    + Send
    + Sync,
) -> impl Fn(Value<I1>, Value<I2>, Value<I3>, Value<I4>, Value<I5>, &mut EvalContext) -> Value<O>
+ Copy
+ Send
+ Sync {
    move |arg1, arg2, arg3, arg4, arg5, ctx| {
        let generics = ctx.generics.to_vec();
        let mut builder = O::create_builder(ctx.num_rows, &generics);
        for index in 0..ctx.num_rows {
            let arg1 = unsafe { arg1.index_unchecked(index) };
            let arg2 = unsafe { arg2.index_unchecked(index) };
            let arg3 = unsafe { arg3.index_unchecked(index) };
            let arg4 = unsafe { arg4.index_unchecked(index) };
            let arg5 = unsafe { arg5.index_unchecked(index) };
            func(arg1, arg2, arg3, arg4, arg5, &mut builder, ctx);
        }
        Value::Column(O::build_column(builder))
    }
}

pub fn passthrough_nullable_1_arg<I1: ArgType, O: ArgType>(
    func: impl for<'a> Fn(Value<I1>, &mut EvalContext) -> Value<O> + Copy + Send + Sync,
) -> impl for<'a> Fn(Value<NullableType<I1>>, &mut EvalContext) -> Value<NullableType<O>>
+ Copy
+ Send
+ Sync {
    move |arg1, ctx| {
        let mut args_validity = arg1.validity(ctx.num_rows);
        if let Some(validity) = ctx.validity.as_ref() {
            args_validity = &args_validity & validity;
        }
        match arg1.value() {
            Some(arg1) => {
                let out = func(arg1, ctx).convert_to_full_column(ctx.num_rows, ctx.generics);
                Value::Column(NullableColumn::new(out, args_validity))
            }
            _ => Value::Scalar(None),
        }
    }
}

pub fn passthrough_nullable_2_arg<I1: ArgType, I2: ArgType, O: ArgType>(
    func: impl for<'a> Fn(Value<I1>, Value<I2>, &mut EvalContext) -> Value<O> + Copy + Send + Sync,
) -> impl for<'a> Fn(
    Value<NullableType<I1>>,
    Value<NullableType<I2>>,
    &mut EvalContext,
) -> Value<NullableType<O>>
+ Copy
+ Send
+ Sync {
    move |arg1, arg2, ctx| {
        let mut args_validity = arg1.validity(ctx.num_rows);
        args_validity = &args_validity & &arg2.validity(ctx.num_rows);
        if let Some(validity) = ctx.validity.as_ref() {
            args_validity = &args_validity & validity;
        }
        match (arg1.value(), arg2.value()) {
            (Some(arg1), Some(arg2)) => {
                let out = func(arg1, arg2, ctx).convert_to_full_column(ctx.num_rows, ctx.generics);
                Value::Column(NullableColumn::new(out, args_validity))
            }
            _ => Value::Scalar(None),
        }
    }
}

pub fn passthrough_nullable_3_arg<I1: ArgType, I2: ArgType, I3: ArgType, O: ArgType>(
    func: impl for<'a> Fn(Value<I1>, Value<I2>, Value<I3>, &mut EvalContext) -> Value<O>
    + Copy
    + Send
    + Sync,
) -> impl for<'a> Fn(
    Value<NullableType<I1>>,
    Value<NullableType<I2>>,
    Value<NullableType<I3>>,
    &mut EvalContext,
) -> Value<NullableType<O>>
+ Copy
+ Send
+ Sync {
    move |arg1, arg2, arg3, ctx| {
        let mut args_validity = arg1.validity(ctx.num_rows);
        args_validity = &args_validity & &arg2.validity(ctx.num_rows);
        args_validity = &args_validity & &arg3.validity(ctx.num_rows);
        if let Some(validity) = ctx.validity.as_ref() {
            args_validity = &args_validity & validity;
        }
        match (arg1.value(), arg2.value(), arg3.value()) {
            (Some(arg1), Some(arg2), Some(arg3)) => {
                let out =
                    func(arg1, arg2, arg3, ctx).convert_to_full_column(ctx.num_rows, ctx.generics);
                Value::Column(NullableColumn::new(out, args_validity))
            }
            _ => Value::Scalar(None),
        }
    }
}

pub fn passthrough_nullable_4_arg<
    I1: ArgType,
    I2: ArgType,
    I3: ArgType,
    I4: ArgType,
    O: ArgType,
>(
    func: impl for<'a> Fn(Value<I1>, Value<I2>, Value<I3>, Value<I4>, &mut EvalContext) -> Value<O>
    + Copy
    + Send
    + Sync,
) -> impl for<'a> Fn(
    Value<NullableType<I1>>,
    Value<NullableType<I2>>,
    Value<NullableType<I3>>,
    Value<NullableType<I4>>,
    &mut EvalContext,
) -> Value<NullableType<O>>
+ Copy
+ Send
+ Sync {
    move |arg1, arg2, arg3, arg4, ctx| {
        let mut args_validity = arg1.validity(ctx.num_rows);
        args_validity = &args_validity & &arg2.validity(ctx.num_rows);
        args_validity = &args_validity & &arg3.validity(ctx.num_rows);
        args_validity = &args_validity & &arg4.validity(ctx.num_rows);
        if let Some(validity) = ctx.validity.as_ref() {
            args_validity = &args_validity & validity;
        }
        match (arg1.value(), arg2.value(), arg3.value(), arg4.value()) {
            (Some(arg1), Some(arg2), Some(arg3), Some(arg4)) => {
                let out = func(arg1, arg2, arg3, arg4, ctx)
                    .convert_to_full_column(ctx.num_rows, ctx.generics);
                Value::Column(NullableColumn::new(out, args_validity))
            }
            _ => Value::Scalar(None),
        }
    }
}

pub fn passthrough_nullable_5_arg<
    I1: ArgType,
    I2: ArgType,
    I3: ArgType,
    I4: ArgType,
    I5: ArgType,
    O: ArgType,
>(
    func: impl for<'a> Fn(
        Value<I1>,
        Value<I2>,
        Value<I3>,
        Value<I4>,
        Value<I5>,
        &mut EvalContext,
    ) -> Value<O>
    + Copy
    + Send
    + Sync,
) -> impl for<'a> Fn(
    Value<NullableType<I1>>,
    Value<NullableType<I2>>,
    Value<NullableType<I3>>,
    Value<NullableType<I4>>,
    Value<NullableType<I5>>,
    &mut EvalContext,
) -> Value<NullableType<O>>
+ Copy
+ Send
+ Sync {
    move |arg1, arg2, arg3, arg4, arg5, ctx| {
        let mut args_validity = arg1.validity(ctx.num_rows);
        args_validity = &args_validity & &arg2.validity(ctx.num_rows);
        args_validity = &args_validity & &arg3.validity(ctx.num_rows);
        args_validity = &args_validity & &arg4.validity(ctx.num_rows);
        args_validity = &args_validity & &arg5.validity(ctx.num_rows);
        if let Some(validity) = ctx.validity.as_ref() {
            args_validity = &args_validity & validity;
        }
        match (
            arg1.value(),
            arg2.value(),
            arg3.value(),
            arg4.value(),
            arg5.value(),
        ) {
            (Some(arg1), Some(arg2), Some(arg3), Some(arg4), Some(arg5)) => {
                let out = func(arg1, arg2, arg3, arg4, arg5, ctx)
                    .convert_to_full_column(ctx.num_rows, ctx.generics);
                Value::Column(NullableColumn::new(out, args_validity))
            }
            _ => Value::Scalar(None),
        }
    }
}

pub fn combine_nullable_1_arg<I1: ArgType, O: ArgType>(
    func: impl for<'a> Fn(Value<I1>, &mut EvalContext) -> Value<NullableType<O>> + Copy + Send + Sync,
) -> impl for<'a> Fn(Value<NullableType<I1>>, &mut EvalContext) -> Value<NullableType<O>>
+ Copy
+ Send
+ Sync {
    move |arg1, ctx| {
        let mut args_validity = arg1.validity(ctx.num_rows);
        if let Some(validity) = ctx.validity.as_ref() {
            args_validity = &args_validity & validity;
        }
        match arg1.value() {
            Some(arg1) => {
                let mut out = func(arg1, ctx).convert_to_full_column(ctx.num_rows, ctx.generics);
                out.validity = &args_validity & &out.validity;
                Value::Column(out)
            }
            _ => Value::Scalar(None),
        }
    }
}

pub fn combine_nullable_2_arg<I1: ArgType, I2: ArgType, O: ArgType>(
    func: impl for<'a> Fn(Value<I1>, Value<I2>, &mut EvalContext) -> Value<NullableType<O>>
    + Copy
    + Send
    + Sync,
) -> impl for<'a> Fn(
    Value<NullableType<I1>>,
    Value<NullableType<I2>>,
    &mut EvalContext,
) -> Value<NullableType<O>>
+ Copy
+ Send
+ Sync {
    move |arg1, arg2, ctx| {
        let mut args_validity = arg1.validity(ctx.num_rows);
        args_validity = &args_validity & &arg2.validity(ctx.num_rows);
        if let Some(validity) = ctx.validity.as_ref() {
            args_validity = &args_validity & validity;
        }
        match (arg1.value(), arg2.value()) {
            (Some(arg1), Some(arg2)) => {
                let mut out =
                    func(arg1, arg2, ctx).convert_to_full_column(ctx.num_rows, ctx.generics);
                out.validity = &args_validity & &out.validity;
                Value::Column(out)
            }
            _ => Value::Scalar(None),
        }
    }
}

pub fn combine_nullable_3_arg<I1: ArgType, I2: ArgType, I3: ArgType, O: ArgType>(
    func: impl for<'a> Fn(Value<I1>, Value<I2>, Value<I3>, &mut EvalContext) -> Value<NullableType<O>>
    + Copy
    + Send
    + Sync,
) -> impl for<'a> Fn(
    Value<NullableType<I1>>,
    Value<NullableType<I2>>,
    Value<NullableType<I3>>,
    &mut EvalContext,
) -> Value<NullableType<O>>
+ Copy
+ Send
+ Sync {
    move |arg1, arg2, arg3, ctx| {
        let mut args_validity = arg1.validity(ctx.num_rows);
        args_validity = &args_validity & &arg2.validity(ctx.num_rows);
        args_validity = &args_validity & &arg3.validity(ctx.num_rows);
        if let Some(validity) = ctx.validity.as_ref() {
            args_validity = &args_validity & validity;
        }
        match (arg1.value(), arg2.value(), arg3.value()) {
            (Some(arg1), Some(arg2), Some(arg3)) => {
                let mut out =
                    func(arg1, arg2, arg3, ctx).convert_to_full_column(ctx.num_rows, ctx.generics);
                out.validity = &args_validity & &out.validity;
                Value::Column(out)
            }
            _ => Value::Scalar(None),
        }
    }
}

pub fn combine_nullable_4_arg<I1: ArgType, I2: ArgType, I3: ArgType, I4: ArgType, O: ArgType>(
    func: impl for<'a> Fn(
        Value<I1>,
        Value<I2>,
        Value<I3>,
        Value<I4>,
        &mut EvalContext,
    ) -> Value<NullableType<O>>
    + Copy
    + Send
    + Sync,
) -> impl for<'a> Fn(
    Value<NullableType<I1>>,
    Value<NullableType<I2>>,
    Value<NullableType<I3>>,
    Value<NullableType<I4>>,
    &mut EvalContext,
) -> Value<NullableType<O>>
+ Copy
+ Send
+ Sync {
    move |arg1, arg2, arg3, arg4, ctx| {
        let mut args_validity = arg1.validity(ctx.num_rows);
        args_validity = &args_validity & &arg2.validity(ctx.num_rows);
        args_validity = &args_validity & &arg3.validity(ctx.num_rows);
        args_validity = &args_validity & &arg4.validity(ctx.num_rows);
        if let Some(validity) = ctx.validity.as_ref() {
            args_validity = &args_validity & validity;
        }
        match (arg1.value(), arg2.value(), arg3.value(), arg4.value()) {
            (Some(arg1), Some(arg2), Some(arg3), Some(arg4)) => {
                let mut out = func(arg1, arg2, arg3, arg4, ctx)
                    .convert_to_full_column(ctx.num_rows, ctx.generics);
                out.validity = &args_validity & &out.validity;
                Value::Column(out)
            }
            _ => Value::Scalar(None),
        }
    }
}

pub fn combine_nullable_5_arg<
    I1: ArgType,
    I2: ArgType,
    I3: ArgType,
    I4: ArgType,
    I5: ArgType,
    O: ArgType,
>(
    func: impl for<'a> Fn(
        Value<I1>,
        Value<I2>,
        Value<I3>,
        Value<I4>,
        Value<I5>,
        &mut EvalContext,
    ) -> Value<NullableType<O>>
    + Copy
    + Send
    + Sync,
) -> impl for<'a> Fn(
    Value<NullableType<I1>>,
    Value<NullableType<I2>>,
    Value<NullableType<I3>>,
    Value<NullableType<I4>>,
    Value<NullableType<I5>>,
    &mut EvalContext,
) -> Value<NullableType<O>>
+ Copy
+ Send
+ Sync {
    move |arg1, arg2, arg3, arg4, arg5, ctx| {
        let mut args_validity = arg1.validity(ctx.num_rows);
        args_validity = &args_validity & &arg2.validity(ctx.num_rows);
        args_validity = &args_validity & &arg3.validity(ctx.num_rows);
        args_validity = &args_validity & &arg4.validity(ctx.num_rows);
        args_validity = &args_validity & &arg5.validity(ctx.num_rows);
        if let Some(validity) = ctx.validity.as_ref() {
            args_validity = &args_validity & validity;
        }
        match (
            arg1.value(),
            arg2.value(),
            arg3.value(),
            arg4.value(),
            arg5.value(),
        ) {
            (Some(arg1), Some(arg2), Some(arg3), Some(arg4), Some(arg5)) => {
                let mut out = func(arg1, arg2, arg3, arg4, arg5, ctx)
                    .convert_to_full_column(ctx.num_rows, ctx.generics);
                out.validity = &args_validity & &out.validity;
                Value::Column(out)
            }
            _ => Value::Scalar(None),
        }
    }
}
